# RTL Design using Verilog with SKY130 Technology  
[![sky130RTLWorkshopLOGO](https://user-images.githubusercontent.com/68154219/165596584-9e7f0e31-4797-4b04-960a-a5a5e63f0ef3.PNG)](https://www.vlsisystemdesign.com/rtl-design-using-verilog-with-sky130-technology/?awt_a=5L_6&awt_l=MhARG&awt_m=3Zzzz39ugcA8._6)

## Brief Description of the Workshop
Workshop intends to teach the verilog coding guidelines that results in predictable logic in Silicon. it is important to note that every verilog code is not synthesizable and even if it is , it may result in different logic depending on the coding styles used. The course details all these aspects of the Verilog HDL with theory and backed with lot of practical examples. Workshop introduces to the digital logic design using Verilog HDL . Validating the functionality of the design using Functional Simulation. Writing Test Benches to validate the functionality of the RTL design. Logic synthesis of the Functional RTL Code. Gate Level Simulation of the Synthesized Netlist.

# *Index*
***
* [Day 1: Introduction to Verilog RTL Design and Synthesis](#Day-1-Introduction-to-Verilog-RTL-Design-and-Synthesis)
  * [Introduction to open-source simulator iverilog](#Introduction-to-open-source-simulator-iverilog)
    * [Introduction to iverilog Design Testbench](#Introduction-to-iverilog-Design-Testbench)
  * [Labs using iverilog and gtkwave](#Labs-using-iverilog-and-gtkwave)
    * [Introduction to Lab](#Introduction-to-Lab)
    * [Introduction iverilog gtkwave Part 1](#Introduction-iverilog-gtkwave-Part-1)
    * [Introduction iverilog gtkwave Part2](#Introduction-iverilog-gtkwave-Part-2)
  * [Introduction to Yosys and Logic Synthesis](#Introduction-to-Yosys-and-Logic-Synthesis)
    * [Introduction to yosys](#Introduction-to-yosys)
    * [Introduction to Logic Synthesis Part 1](#Introduction-to-Logic-Synthesis-Part-1)
    * [Introduction to Logic Synthesis Part 2](#Introduction-to-Logic-Synthesis-Part-2)
  * [Labs using Yosys and Sky130 PDKs](#Labs-using-Yosys-and-Sky130-PDKs)
    * [Yosys 1 good mux Part 1](#Yosys-1-good-mux-Part-1)
    * [Yosys 1 good mux Part 2](#Yosys-1-good-mux-Part-2)
    * [Yosys 1 good mux Part 3](#Yosys-1-good-mux-Part-3)
    
 # Day 1: Introduction to Verilog RTL Design and Synthesis
 ***
 ## Introduction to open-source simulator iverilog

 #### *What was learnt*
 #### Terms such as
 * ## Design
    * Design is an actual Verilog code or set of Verilog codes which has the intended functionality
      to meet with the required specifications.
 * ## Testbench 
    * Testbench is the setup to apply stimulus (test_vectors) to the design to check its functionality. 
    * Verification is required to ensure the design meets the timing and functionality requirements.
    * Verilog Testbenches are used to simulate and analyze designs without the need for any physical hardware or any hardware device
 * ## Simulator and how the simulator works
    * RTL design is checked for adherence to the spec by simulating the design
    * Simulator is the tool for simulating the design 
    * Simulator looks for the changes on the input signals
    * Upon change to the input, output is evaluated. That is, if there is no change to input, there is no change to output
 * ## iVerilog
    * We are using iVerilog as simulating tool for labs
    * [Icarus Verilog](http://iverilog.icarus.com/) or iVerilog is a Verilog simulation and synthesis tool.
    * It operates as a compiler, compiling source code written in Verilog (IEEE-1364) into some target format.
 * ## Value Change Dump Format
    * A Value Change Dump File (.vcd file) is an ASCII file which contains header information, variable definitions, and the value changes for specified variables, or all variables, in a given design. 
    * The value changes for a variable are given in scalar or vector format, based on the nature of the variable. 
    * Verilog VCD file is generated by EDA Logic Simulation Tools
 * ## GTKWave 
    *  [GTKWave](http://gtkwave.sourceforge.net/) is a VCD waveform viewer based on the GTK library. This viewer support VCD and LXT formats for signal dumps.
    *  Waveform dumps are written by the Icarus Verilog runtime program [vvp](https://iverilog.fandom.com/wiki/Vvp_Flags)
    *  The user uses $dumpfile and $dumpvars system tasks to enable waveform dumping, then the vvp runtime takes care of the rest.
    *   The output is written into the file specified by the $dumpfile system task. 
    *   The example below dumps everything in and below the tb_good_mux module.
    <p align="center" width="100%">
    <img src="https://user-images.githubusercontent.com/68154219/165763562-4f431070-a810-4a8b-95fc-2228fe0bc754.png"> 
    </p>
    
    * The $dumpvars is used to dump the changes in the values of nets and registers in a file that is named as its argument
    * The $dumpvars is used to specify which variables are to be dumped ( in the file mentioned by $dumpfile)
    * The general syntax of the $dumpvars include two arguments as in
      $dumpvars(<levels> , <module_or_variable> );
    * When level is set to 0, and only the module name is specified, it dumps ALL the variables of that module and all the variables in ALL lower level modules instantiated by this top module. If any module in not instantiated by this top module, then its variable will not be covered.

### Introduction to iverilog Design Testbench
 ### Design and Testbench setup
 1. Design Setup :
 
<p align="center" width="100%">
    <img src="https://user-images.githubusercontent.com/68154219/165711560-36ce90db-1b59-4405-b330-6f2d066e1ed5.PNG"> 
</p>

 A Design has more than one primary inputs and primary outputs.

2. Testbench Setup :
 
 <p align="center" width="100%">
 <img src="https://user-images.githubusercontent.com/68154219/165723917-0018cc34-3451-4f8a-883a-594a6b85c030.png">
 </p>
 All the primary input are given stimulus generator and all primary outputs are given to stimulated observer in a testbench. So, testbench does not have a primary input or primary output.
 
 ### iVerilog based Simulation Flow
 
 <p align="center" width="100%">
 <img src="https://user-images.githubusercontent.com/68154219/165758468-745eb0c9-855e-4409-9179-8098d6bdd707.png">
 </p>
 
* Design and Testbench are applied to the iVerilog simulator tool
* Output of the simulator is a vcd file
* vcd file is viewed using gtkwave viewer

 ## Labs using iverilog and gtkwave
#### *Labs*
#### Lab 1: Introduction to Lab
 * #### Setting up the environment for all the labs
 <p align="center" width="100%">
 <img src="https://user-images.githubusercontent.com/68154219/165773236-2c33f8ba-a254-4411-9943-631d0431d890.png">
 </p>
 
 #### Lab 2: Introduction iverilog gtkwave Part 1
 * #### Loading the design (good_mux.v file) and testbench file (tb_good_mux.v) to iverilog to generate a.out output file
 <p align="center" width="100%">
 <img src="https://user-images.githubusercontent.com/68154219/165775238-8e39ccdf-fc51-4bda-8172-543b628a256f.png">
 </p>
 
* #### Opening the vcd file (tb_good_mux.vcd) and checking its functionality on gtkwave viewer
 <p align="center" width="100%">
 <img src="https://user-images.githubusercontent.com/68154219/165779132-571f8736-442f-4241-ad91-6cea5867cecb.png">
 </p>
  The waveform demonstrates that the output triggers on positive clock edge. The logic of the design can be understand from the waveform as the output follows input i0 when sel signal is LOW and follows input i1 when sel signal is HIGH.
 
 
 #### GTKWAVE VIEWER
<p align="center" width="100%">
 <img src="https://user-images.githubusercontent.com/68154219/165780807-53e3f295-a452-4e4f-8f4b-0f1f76cf166f.PNG">
 </p>

 #### Lab 3: Introduction iverilog gtkwave Part 2
 * #### Looking into file structure
 <p align="center" width="100%">
 <img src="https://user-images.githubusercontent.com/68154219/165806522-1e0132c0-6a1e-4954-af4c-9ca09eaf3758.png">
 </p>
 
 * #### Design good_mux verilog file 
 <p align="center" width="100%">
 <img src="https://user-images.githubusercontent.com/68154219/165809109-1c65c82b-468f-419b-921e-e76f3fbd863b.png">
 </p>
 
 * #### Testbench tb_good_mux verilog file
 <p align="center" width="100%">
 <img src="https://user-images.githubusercontent.com/68154219/165813337-6ecaf95b-38de-421a-806c-8d9612c1b1dc.png">
 </p>
<p align="center" width="100%">
<img src="https://user-images.githubusercontent.com/68154219/165813505-59f026d0-80d7-4ab1-b42e-8a6c3fff284e.png">
</p>

In testbench, stimulus generator sets sel, i0, i1 to zero. The simulation runs for 300 nano seconds. 
  - The sel input is toggled after every 75 nano seconds
  - The i0 input is toggled after every 10 nano seconds
  - The i1 input is toggled after every 55 nano seconds
***
 ## Introduction to Yosys and Logic Synthesis
  #### *What was learnt*
 #### Terms such as
 * ## RTL
   * Stands for [Register Transfer Level](https://inst.eecs.berkeley.edu/~ee290c/sp18/lec/Lecture12A.pdf)
   * An abstraction for digital circuits, consisting of 
     * Combinational logic
     * Registers (state elements)
     * Modules (hierarchical and “blackbox” - e.g. analog macros, SRAM macros, etc) and ports/nets
   * Behavioural representation of the required specification.
   * Described in terms of a hardware description language (HDL)
 * ## Netlist 
   * A netlist is textual description of a circuit made of components in VLSI design. 
   * Components are: gates, resistors, capacitors or transistors. Connection of these components are called netlist.
   * Netlist contains the information regarding logical connectivity of all standard cells and macros.
   * Physical design will convert the gate level netlist in complete physical geometric representation. The file produced at the output of the layout is the GDSII (GDS2) FILE or oas which is the file used by the foundry to fabricate the silicons.
 * ## Synthesizer
   * Tool used for converting RTL to netlist.
   * [Yosys](https://www.yosyshq.com/open-source) is the synthesizer used in this course.
   * Yosys is the pure open source software and is a framework for RTL synthesis and more
   * Yosys currently has extensive Verilog-2005 support and provides a basic set of synthesis algorithms for various application domains. It is the core component of most our implementation and verification flows.
 * ## .lib 
   * Collection of logical modules
   * Includes basic logic gates like AND, OR, NOT, etc.
   * Consists of different flavours of same gate like 
     * 2 input AND gate with Slow, Medium and Fast versions,
     * 3 input AND gate with Slow, Medium and Fast versions,
     * 4 input AND gate with Slow, Medium and Fast versions, etc.
 
 ### Introduction to yosys
 ### Yosys Setup
 
 <p align="center" width="100%">
 <img src="https://user-images.githubusercontent.com/68154219/165822673-82cec922-2270-4837-a3e2-ef15ecac8fb5.png">
 </p>
 
 Design and .lib ([verilog liberty](https://www.teamvlsi.com/2020/05/lib-and-lef-file-in-asic-design.html#:~:text=LIB%20file%20is%20an%20ASCII,time%20requirement%20of%20the%20cell.)) files are loaded in the yosys synthesizer. The output is the netlist file.
 The netlist is the representation of the design in form of the cells present in the .lib file
 *  *read_verilog* command is used for reading design file.
 *  *read_liberty* command is used for reading lib file.
 *  *write_verilog* command is used for writing design file.
 
 ### Verify the Synthesis
 
 <p align="center" width="100%">
 <img src="https://user-images.githubusercontent.com/68154219/165824923-1191db78-9085-4905-975f-4ffcde968b7d.png">
 </p>
 
* Netlist and Testbench files are loaded in iverilog simulator. 
* The output vcd file is observed in the gtkwave viewer. 
* If this output and the RTL simulation output are same then the netlist output of the synthesier is verified to be correct.
* This concludes that the primary inputs and outputs between RTL design and Synthesized netlist will remain the same. So, the same testbench can be used for both. 

### Introduction to Logic Synthesis Part 1
 
 
 
 
 
 

 

 
